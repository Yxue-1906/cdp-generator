// This file is generated by DevtoolsValue_h.template.

// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#pragma once

#include "td/utils/misc.h"
#include "td/utils/JsonBuilder.h"

{% for namespace in namespaces %}
namespace {{namespace}} {
{% endfor %}

using Number = double;
using String = std::string;
using Integer = int;
using Binary = std::string;
using Boolean = bool;
using Any = class DevtoolsAny;

template<class T> using Ptr = td::unique_ptr<T>;
template<class T> using Array = std::vector<T>;

namespace detail {
  template<class T, class = void>
  struct HasCStr : std::false_type {};

  template<class T>
  struct HasCStr<T, std::void_t<decltype(std::declval<T>().c_str())>> : std::true_type {};

  template<class T, class = void>
  struct HasDataOnly : std::false_type {};

  template<class T>
  struct HasDataOnly<T, std::void_t<decltype(std::declval<T>().data())>> : std::true_type {};

  // copyright https://mikejsavage.co.uk/cpp-tricks-compile-time-string-hashing/
  constexpr uint64_t Hash64_CT(const char * str, size_t n, uint64_t basis = UINT64_C( 14695981039346656037 ) ) {
    return n == 0 ? basis : Hash64_CT( str + 1, n - 1, ( basis ^ str[ 0 ] ) * UINT64_C( 1099511628211 ) );
  }

  template< size_t N >
  constexpr uint64_t Hash64_CT(const char ( &s )[ N ] ) {
    return Hash64_CT( s, N - 1 );
  }

  template<class T, std::enable_if_t<detail::HasCStr<T>::value, int> = 0>
  uint64_t Hash64_CT(const T &s) {
    return Hash64_CT(s.c_str(), s.size());
  }

  template<class T, std::enable_if_t<detail::HasDataOnly<T>::value, int> = 0>
  uint64_t Hash64_CT(const T &s) {
    return Hash64_CT(s.data(), s.size());
  }
}

class DevtoolsAny : td::Jsonable {
 public:
  const td::JsonValue &get_value() const {
    return value_;
  }
  td::JsonValue &get_value() {
    return value_;
  }

  static td::Result<Any> parse(const td::JsonValue &value) {
    auto s = td::json_encode<td::string>(value);
    TRY_RESULT(v, td::json_decode(s));
    return DevtoolsAny{std::move(s), std::move(v)};
  }
  inline void store(td::JsonValueScope *store) const {
    *store << get_value();
  }
  DevtoolsAny clone() const {
    return {td::json_encode<String>(value_)};
  }
 private:
  String storage_;
  td::JsonValue value_;

  DevtoolsAny(String storage, td::JsonValue value) : storage_(std::move(storage)) , value_(std::move(value)){
  }
  DevtoolsAny(String storage) : storage_(std::move(storage)) {
    value_ = td::json_decode(storage_).move_as_ok();
  }
};

class DevtoolsValue : td::Jsonable {
 public:
  virtual ~DevtoolsValue() = default;

  virtual void store(td::JsonValueScope *store) const = 0;
};

class DevtoolsCommand : td::Jsonable {
 public:
  virtual ~DevtoolsCommand() = default;

  virtual td::Slice method() const = 0;
  virtual void store(td::JsonValueScope *store) const = 0;
};

class DevtoolsEvent : td::Jsonable {
 public:
  virtual ~DevtoolsEvent() = default;

  String session_;

  virtual td::Slice name() const = 0;
  virtual td::uint64 id() const = 0;
  virtual Ptr<DevtoolsEvent> clone() const = 0;
  virtual void store(td::JsonValueScope *store) const = 0;
};

namespace detail {
  template<class, class = void>
  struct GetParseFuncResType{};

  template<class T>
  struct GetParseFuncResType<T, std::void_t<decltype(T::parse(std::declval<const td::JsonValue &>()))>> {
    using ResType = decltype(T::parse(std::declval<const td::JsonValue &>()));
  };

  template<class, class = void>
  struct HasParseFunc : std::false_type {
  };

  template<class T>
  struct HasParseFunc<T, std::enable_if_t<
      std::is_same_v<td::Result<T>, typename GetParseFuncResType<T>::ResType> ||
      std::is_same_v<td::Result<Ptr<DevtoolsEvent>>, typename GetParseFuncResType<T>::ResType>
      >> : std::true_type {
  };

  template<class, class = void>
  struct GetCloneFuncResType{};

  template<class T>
  struct GetCloneFuncResType<T, std::void_t<decltype(std::declval<T>().clone())>> {
    using ResType = decltype(std::declval<T>().clone());
  };

  template<class, class = void>
  struct HasCloneFunc : std::false_type {};

  template<class T>
  struct HasCloneFunc<T, std::enable_if_t<
      std::is_same_v<T, typename GetCloneFuncResType<T>::ResType> ||
      std::is_same_v<Ptr<DevtoolsEvent>, typename GetCloneFuncResType<T>::ResType>>> : std::true_type {
  };

  template<class T1, class T2>
  td::Status try_assign(T1 &, T2 &) {
    static_assert(sizeof(T1) + sizeof(T2) == -1, "Ill-formed use");
    UNREACHABLE();
  }

  template<class T>
  inline td::Status try_assign(T &v1, T &&v2) {
    v1 = std::move(v2);
    return td::Status::OK();
  }

  template<class T>
  inline td::Status try_assign(T &v, td::Result<T> &&r) {
    TRY_RESULT_ASSIGN(v, std::move(r));
    return td::Status::OK();
  }

  template<class T>
  inline td::Status try_assign(Ptr<T> &v, td::Result<T> &&r) {
    if(r.is_error()) {
      return r.move_as_error_unsafe();
    }
    v = td::make_unique<T>(r.move_as_ok_unsafe());
    return td::Status::OK();
  }

  template<class T>
  struct DevtoolsParser {
    template<class T1 = T, std::enable_if_t<HasParseFunc<T1>::value, int> = 0>
    static auto parse(const td::JsonValue &value) {
      return T::parse(value);
    }
  };

  template<class T>
  struct DevtoolsParser<Ptr<T>> {
    static td::Result<Ptr<T>> parse(const td::JsonValue &value) {
      TRY_RESULT(result, DevtoolsParser<T>::parse(value));
      return td::make_unique<T>(std::move(result));
    }
  };

  template<class T>
  struct DevtoolsParser<Array<T>> {
    static td::Result<Array<T>> parse(const td::JsonValue &value) {
      if (value.type() != td::JsonValueType::Array) {
        return td::Status::Error(400, "Parse array failed");
      }
      auto &array = value.get_array();
      Array<T> result;
      result.reserve(array.size());
      for (auto &element: array) {
        TRY_RESULT(parse_result, DevtoolsParser<T>::parse(element));
        result.push_back(std::move(parse_result));
      }
      return result;
    }
  };

  template<>
  struct DevtoolsParser<Integer> {
    static td::Result<Integer> parse(const td::JsonValue &value) {
      if (value.type() != td::JsonValueType::Number) {
        return td::Status::Error(400, "Parse int failed");
      }
      return td::to_integer_safe<Integer>(value.get_number());
    }
  };

  template<>
  struct DevtoolsParser<Boolean> {
    static td::Result<Boolean> parse(const td::JsonValue &value) {
      if (value.type() != td::JsonValueType::Boolean) {
        return td::Status::Error(400, "Parse bool failed");
      }
      return value.get_boolean();
    }
  };

  template<>
  struct DevtoolsParser<Number> {
    static td::Result<Number> parse(const td::JsonValue &value) {
      if (value.type() != td::JsonValueType::Number) {
        return td::Status::Error(400, "Parse double failed");
      }
      return td::to_double(value.get_number());
    }
  };

  template<>
  struct DevtoolsParser<String> {
    static td::Result<String> parse(const td::JsonValue &value) {
      if (value.type() != td::JsonValueType::String) {
        return td::Status::Error(400, "Parse string failed");
      }
      auto &str = value.get_string();
      return str.str();
    }
  };


  template<class T>
  struct DevtoolsValueClone {
    template<class T1 = T, std::enable_if_t<HasCloneFunc<T1>::value, int> = 0>
    static auto clone(const T1 &base) {
      return base.clone();
    }
    template<class T1 = T, std::enable_if_t<!HasCloneFunc<T1>::value, int> = 0>
    static auto clone(const T1 &base) {
      return base;
    }
  };

  template<class T>
  struct DevtoolsValueClone<Ptr<T>> {
    static auto clone(const Ptr<T> &base) {
      return td::make_unique<T>(DevtoolsValueClone<T>::clone(*base));
    }
  };

  template<class T>
  struct DevtoolsValueClone<Array<T>> {
    static auto clone(const Array<T> &base) {
      Array<T> result;
      result.reserve(base.size());
      for (auto &element: base) {
        result.push_back(DevtoolsValueClone<T>::clone(element));
      }
      return result;
    }
  };


  template<class T>
  struct DevtoolsValueToJson {
    template<class T1>
    static decltype(auto) to_json(T1 &&v) {
      return v;
    }
  };

  template<>
  struct DevtoolsValueToJson<bool> {
    static td::JsonBool to_json(bool v) {
      return td::JsonBool(v);
    }
  };

  template<class T>
  struct DevtoolsValueToJson<Array<T>> {
    static decltype(auto) to_json(const Array<T> &v) {
      return td::json_array([&v] (auto &a) {
        for(auto &e: v) {
          a(DevtoolsValueToJson<T>::to_json(e));
        }
      });
    }
  };

  template<class T>
  struct DevtoolsValueToJson<Ptr<T>> {
    inline static decltype(auto) to_json(const Ptr<T> &v) {
      return DevtoolsValueToJson<T>::to_json(*v);
    }
  };

}

template<class T1, class T2>
void clone_devtools_value(T1 &result, const T2 &base) {
  result = detail::DevtoolsValueClone<T2>::clone(base);
}

template<class T>
td::Status parse_devtools_value(T &result, const td::JsonValue &value) {
  TRY_STATUS(detail::try_assign(result, detail::DevtoolsParser<T>::parse(value)));
  return td::Status::OK();
}

td::Result<Ptr<DevtoolsEvent>> parse_devtools_event(td::JsonValue &value);

template<class T>
decltype(auto) devtools_value_to_json(const T &v) {
  return detail::DevtoolsValueToJson<T>::to_json(v);
}

{% for namespace in namespaces %}
} // namespace {{namespace}}
{% endfor %}
